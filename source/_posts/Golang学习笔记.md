---
title: Golang学习笔记
date: 2018-08-15 20:04:36
tags:
---

# Golang学习笔记

## 变量, 类型和关键字

#### 变量

var 声明创建一个具体类型的变量 `var name type = expression`

* type指变量类型
* expression指表达式

两者可以省略一个, 但不能同时省略. 当类型省略时, 类型由初始化表达式决定. 如果表达式省略, 其初始值对应类型的零值. (对于数字是0, 对于布尔值是false, 对于字符串是"", 对于接口和引用类型(slice, 指针, map, channel, 函数)其零值是nil)

#### 其他

* 在Go语言中, 变量的声明与赋值是两个过程, `:=` 符号可以一步完成声明及赋值两步, 这一形式只能用在函数中. 这种情况下, 变量的类型由值推演出来的. 
* var, const, import 可以使用 `()` 声明一组变量.
* 特殊变量名: `_`(下划线), 任何赋值给它的值都会被丢弃掉.
* Go的编译器会对: **声明后却未使用的变量**编译时报错.
* 布尔类型: bool, 值为预定义常量, `true` 和 `false`
* 数字类型: int, 此类型根据平台硬件决定其长度. 32位硬件长度为`32`, 64位的硬件长度为`64`. 如果希望明确长度, 可以使用 `int32`, `int64`. 

    * 完整的整数类型列表

        * 符号: int8, int16, int32, int64
        * 无符号: byte, uint8, uint16, uint32, uint64

    * 浮点类型: float32, float64

* 常量: 使用`const`关键字声明.

    * 关键字`iota`, 生成枚举值, 在 `()` 组内声明变量时, 第一个值使用 `iota`, 其余值一次累加1, 且可省略掉`iota`. 在组外`()`使用iota, 每次都会初始化新值为0

* 字符串: `string`

    * 使用`"`包裹
    * `'` 单引号表示字符, 非字符串.
    * 多行字符串可以使用 `"" + ""` 拼接, 注意 `+` 符号必须在第一行的结尾处, 还可以使用`\`\``符号标示多行字符.

* 错误类型: `error`

    错误类型是一个接口.
    
## 控制结构

go只有很少的几个控制结构: `if`, `for`, `switch`, `select`(类型选择和多路通讯转换器). 

控制语句与c有些不同, 不需要圆括号(), 且语句体必须包含在大括号内{}.

* `if`, `switch`: 接受初始化语句, 通常用于设置一个(局部)变量.
* 用于结束控制语句的关键字: `break`, `continue`, `return`, `goto`

> 平行赋值: a, b = b, a

* `break`: 终止离它最近的循环
* `continue`: 进入离他最近的下一次循环
* 关键字: `range`, 是一个迭代器, 可以用在对象为: `slice`, `array`, `string`, `map`, `channel`. 针对不同类型的对象, 返回的k, v值是不一样的.
* `switch`: 表达式不必为常量或整数, 可以是true的表达式, 执行过程, 自上向下, 直到找到匹配项, 如果没有匹配项, 可以匹配结果为true的表达式. 

    * `fallthrough`: 可以穿透 case项, 匹配下一项
    * `default`: 可以匹配当所有case项都不匹配的情况.
    * `case`后面, 可以使用逗号`,`分割多个表达式, 形成case列表.

## 内建函数

go语言內建了少数函数, 这意味着无需引用任何包就可以使用.

![w500](media/15321541124095/15062610979454.jpg)

* `close`: 用于channel通信, 使用close关闭channel.
* `delete`: 用于删除map中的实例
* `len`和`cap`: 用于不同类型的长度值, `len`用于字符串, slice和数组的长度. 
* `new` 用于各种类型的内存分配
* `make` 用于内建类型(map, slice, channel)的内存分配.
* `copy` 用于复制slice
* `append` 用于追加 slice
* `panic` 和 `recover` 用于异常处理机制.
* `print` 和 `println` 可以再不导入`fmt`包的情况下打印, 主要用于调试.
* `complex`, `real`, `imag`: 用于处理复数

## array, slice, map

#### array

* 数组是具有固定长度且拥有零个或多个相同数据类型元素的序列。
* 默认情况下，一个数组中的元素初始值为元素类型的零值。也可以使用*数组字面量*根据一组值来初始化一个数组。
* 在数组字面量中，如果省略号`...`出现在数组长度的位置，那么数组的长度由初始化数组的元素长度个数决定。
* 语法定义: [n]<type>, n: 表示长度, type: 表示希望存储的类型.
* 数组是值类型, 将一个数组赋值给另一个数组, 会复制所有的元素. 如函数的传递变量, 它会获取一个数组的副本, 而不是数组的指针.
* 数组的长度不能改变
* 字面量初始化数组: `a := [3]int{1, 2, 3}` 或 `a = [...]int{1, 2, 3}`
* 数组比较直接使用 `==`

#### slice

与 array 类似, 区别: 可增加长度. slice总是指向底层的一个array, slice是指向array的指针.

* slice 表示一个拥有相同类型元素的可变长度的序列。
* slice 看上去像没有长度的数组类型。
* slice有三个属性：指针，长度和容量。长度不能超过容量
* len()：返回slice的长度
* cap()：返回slice的容量
* slice是引用类型, 当一个slice赋值给另slice时, 两个变量会引用同一个array. 
* 语法定义: 

    * 注意初始化 slice 的表达式与初始化数组的表达式的区别。 slice 初始化字面量看上去和数组字面量很像， 但是slice没有制定长度。`a = []int{1,2,3}`
    * `sl := make([]int, 10)`, 创建一个初始化长度为10, 内部元素为int的slice.  
    * 可以从已有数组或slice生成新的slice, 如: `a[2:5]` , 从数组(或slice)中序号为2的,到序号为5的创建一个新的slice. 省略2, 5, 只用[:]表示(这是[0: len(a)]的简写形式), 用数组全部元素初始化一个slice.

* 必须使用`append`追加元素. append会返回一个新的slice. 即必须使用一个变量接收append函数的返回值。
* `length := copy(s1, s2)`用于对slice的复制. s1: 目标slice, s2: 复制源slice, length: 复制最终的长度. 长度 = s1或s2长度的最小值.
* slice比较不能使用 `==`， 字节数组可以使用 函数`bytes.Equal`比较， 其他类型slice需要自己写函数来进行比较。
* slice 并不是纯引用类型， 而是一种聚合类型。
* 

#### `map`

map可以被认为是一个字符串做索引的数组.

* 定义: map[key type]<value type>
* 声明: make(map[key type]<value type>)
* 一句话声明+定义: 

    ```go

    args1 := map[key type]<value type>{ key: value, key: value} // 字面量声明
    args2 := make(map[key type]<value type>) // make()函数声明
    args3 := map[key type]<value type>{}
    
    ```
* 新增元素: map[key] = value
* 删除元素: delete(map, key)
* 检测是否存在: value, present = map[key]

    > 使用 sort.Strings() 对字符串数组排序
    
* map 的零值是nil，所以向零值的map赋值会错误，必须对map进行初始化
* map 与 slice 一样，都不可比较(==)，需要自定义比较

#### 结构体

结构体是将零个或者多个任意类型的命名变量组合在一起的聚合数据类型。每个变量都叫结构体的成员。

* 结构体的比较：如果结构体中每个成员都可比较，则接口体也是可比较的。且是按照成员顺序比较。且和其他可比较类型一样，可比较的结构体都可以作为map的键类型。

#### JSON

* 成员标签定义是结构体成员在编译期间关联的一些元信息。

## 函数

go不允许函数嵌套, 但是可以利用匿名函数实现. 

#### Panic, Recover

go使用了 panic-and-recover 机制.

> 一定要记得, 这应该作为最后的手段被使用.

* Panic
    
    内建函数, 可以中断原有的控制流程. 进入Panic函数.
    
* Recover
    
    内建函数, 可以让进入Panic的流程中的gorountine恢复过来. 
    

## 包

包是函数和数据的集合. 用 package 关键字定义一个包. 文件名不需要与包名一致. 包名的约定是使用小写字符. 

* 公有函数的名字以大写字母开头;
* 私有函数的名字以小写字母开头.

这个规则同样适用于定义在包中的其他名字(新类型, 全局变量). 

#### 标示符

* 包名

    当包导入(import)时, "包名"成为内容的入口.
    
    * 包名是导入的默认名称. 可以通过在导入语句指定其他名称来覆盖默认名称:

        `import bar "bytes"`
        
        这意味着: 包名无需全局唯一. 在少有的冲突中, 可以给导入的包选择另一个名字在局部使用.
    
    * 包名就是代码的根目录名: 在 `src/pkg/compress/gzip` 的包, 包名是gzip

#### 包的文档

每个包都应该有包注释, 在 package 前的一个注释块. 对于多文件包, 包注释只需要出现在一个文件前, 任意一个文件都可以.

#### 测试包

`go test` 程序调用了所有的测试函数. 编写测试需要包含 testing 包和程序 go test. 

测试文件名: *_test.go
测试函数名: TestXxxxx

#### 常用的包

* fmt

    包 fmt 实现了格式化的 I/O 函数, 

* io

    io操作
    
* bufio

    缓冲IO, 封装于 io.Reader 和 io.Writer 对象
    
* sort

    sort 包提供了对数组和用户定义集合的原始排序功能.
    
* strconv

    strconv 包提供了将字符串转成基本数据类型, 或者从基本数据类型转为字符串的功能.
    
* os

    os 包提了与平台无关的操作系统功能接口
    
* sync

    sync 包提供了基本的同步原语. 如: 互斥锁.
    
* flag

    flag 包实现了命令行解析.
    
* encoding/json

    实现了编码与解码 RFC 4627定义的JSON对象
    
* html/template

    数据驱动的模板, 用于生成文本输出, 例如HTML
    
* net/http

    net/http 实现了http请求, 相应和URL的解析, 并且提供了可扩展的HTTP服务和基本的HTTP客户端.
    
* unsafe

    unsafe 包包含了 Go 程序中的数据类型上所有不安全操作.

* reflect

    reflect 包实现了运行时反射, 允许程序通过抽象类型操作对象. 通常用于处理静态类型 interface{} 的值. 并且通过 Typeof 解析出其动态类型信息, 通常会返回一个有接口类型的 Type 对象.
    
* os/exec

    os/exec 包执行外部命令.
    
# 进阶

Go 有指针. 然而却没有指针运算, 因此他们更像是引用, 而不是你所知道来自于C的指针.

指针的定义: 通过类型作为前缀来定义一个指针"*", 如: var p *int. 现在 p 是一个指向整数值的指针. 

> 一个新定义的或者没有任何指向的指针, 值为 `nil`

* 指针指向: 让指针指向某些内容, 可以使用取址操作符 `&`, 从指针获取值是**通过在指针变量前置`*`**实现的 如:

```go
var p *int
var i int

p = &i // 指针 p 指向 i
*p = 8 // 修改 i 的值

```
## 内存分配

Go 有两个内存分配原语: new 和 make. 他们应用于不同的类型. 

#### new

new(T) 分配了零值填充的 T 类型的内存空间, 并且返回其地址, 一个 *T 类型的值. 用 Go 的属于说, 它返回了一个指针, 指向新分配的类型 T 的零值.

#### make

make 只能创建 slice, map 和 channel, 并且返回一个有初始值(非零)的T类型, 而不是 *T, 

> make 仅适用于 map, slice 和 channel, 并且返回的不是指针. 应当用 new 获得特定的指针.

* new(T) 返回 *T 指向一个零值T
* make(T) 返回初始化后的T, 且make仅适用于slice, map 和 channel

#### 构造函数与复合声明

有时零值不能满足需求, 必须要有一个用于初始化的构造函数.

> new(File) 和 &File{} 是等价的.
> 从复合声明中获取地址, 意味着告诉编译器在堆中分配空间 而不是栈中.

在特定的环境下, 如果符合声明不包含任何字段, 它创建特定类型的零值. 即: new(File) 和 &File{} 是等价的.

* 复合声明

```go
ar := [...]string{} // 数组的复合声明
sl := []string{} // slice的复合声明
ma := map[int]string{} // map的复合声明
```

#### 定义自己的类型

* 结构字段

* 方法

    > 如果 x 可获取地址, 并且 &x 的方法中包含了m, x.m() 是 (&x).m() 更短的写法.
    
    ```sh
    var n NameAge // 不是指针
    n.doSomething(2)    
    ```
    
    Go 会查找 NameAge 类型的变量 n 的方法列表, 没有找到就会再查找 *NamgeAge类型的方法列表, 并且将其转化为(&n).doSomething(2).
    
* 转换

## 接口, interface

* 在函数中, 可以使用 type switch 获取变量实际的类型, 在 switch 之外使用(type)是非法的.

```go
func f(p I) {
    switch t := p.(type) {
        case *S:
        case *R:
        case S:
        case R:
        default:
    }
}
```

在 switch 之外使用 (type) 是非法的, 类型判断不是唯一的运行时得到类型的方法. 为了在运行时得到类型, 同样可以使用 “comma, ok” 来判断一个接口类型是否实现了某个特定接口。

* 空接口： interface{}，我们可以创建一个接受空接口作为参数的普通函数

## 方法

方法就是接收者的函数。可以在任意类型上定义方法(除了非本地类型， 包括内建类型：int类型不能you方法)。


#### 接口类型的方法

接口定义为一个方法的集合。 方法包含实际的代码。 

#### 接口名字

单腌法接口命名： 方法名加上 `-er` 后缀

#### 自省和反射


## 接口



#### 接口值

一个接口类型的值(简称接口值)其实有两部分：

* 一个具体类型
* 该类型的一个值

两者称为接口的动态类型和动态值。

`var buf *bytes.Buffer`

| 动态类型 | *bytes.Buffer |
| --- | --- |
| 动态值 | nil |

#### 可变参数

`(param ...Type)` 参数 `param` 是一个可变参数, 调用方可以传入任意多个值, 使用时 `param` 可以当做 `[]slice` 来使用.














